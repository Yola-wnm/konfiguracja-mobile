<!DOCTYPE html>
<html lang="pl">
<head>
    <script>
        // Lista dozwolonych domen (bez zmian)
        const allowedDomains = ["bethink.pl", "wiecejnizmatura.pl"];
        function isAllowedReferrer(ref) {
            if (!ref) return false;
            try {
                const url = new URL(ref);
                return allowedDomains.some(domain => url.hostname.endsWith(domain));
            } catch { return false; }
        }
        if (window !== window.parent) {
            const referrer = document.referrer;
            if (!isAllowedReferrer(referrer)) {
                document.body.innerHTML = "<div style='display:flex;justify-content:center;align-items:center;height:100vh;'><h1 style='color:red;text-align:center;font-size:2rem;'>Ta gra mo偶e by osadzana <br>tylko na platformach Bethink lub Wicej ni偶 Matura.</h1></div>";
                throw new Error("Embedding not allowed!");
            }
        }
    </script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Konfiguracja Elektronowa - Gra (Wersja Poprawiona)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&family=Roboto+Mono:wght@700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Lato', sans-serif; background-color: #f3f4f6; }
        h1, h2, h3, #level-title, .obstacle-text { font-family: 'Roboto Mono', monospace; font-weight: 700; }
        @keyframes jump {
            0%   { bottom: 5px; }
            50%  { bottom: 240px; }
            100% { bottom: 5px; }
        }
        .jumping { animation: jump 1.5s ease-out; }
        @keyframes obstacle-move {
            from { right: -250px; }
            to   { right: 110%; }
        }
        .obstacle { animation-name: obstacle-move; animation-timing-function: linear; }
        .electron { animation: fadeIn 0.3s ease-in; }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.5); }
            to { opacity: 1; transform: scale(1); }
        }
    </style>
</head>
<body class="text-gray-800 flex flex-col items-center justify-center min-h-screen p-4">
    <div class="w-full max-w-5xl mx-auto text-center">
        <h1 class="text-3xl md:text-4xl text-gray-800 mb-2">Konfiguracja Elektronowa</h1>
        <div id="level-title" class="text-lg text-pink-500 h-8 mb-2"></div>
        <div id="stats" class="text-base md:text-lg mb-4 h-16 flex flex-col justify-center">
            <p id="info"></p>
        </div>
    </div>

    <div id="game-container" class="relative w-full max-w-5xl h-[26rem] bg-white border-2 border-gray-300 rounded-lg overflow-hidden shadow-lg">
        
        <div id="start-screen" class="absolute inset-0 bg-white/95 p-6 overflow-y-auto z-30">
            <div id="start-screen-content" class="text-center max-w-3xl mx-auto">
                <h2 class="text-2xl text-gray-800 mb-4">Jak Gra?</h2>
                <div class="text-left text-base space-y-4 mb-6">
                    <div>
                        <h3 class="text-pink-500 mb-1">1. WYPENIJ KONFIGURACJ</h3>
                        <p class="text-sm leading-relaxed text-gray-600">Twoim celem jest uzupenienie konfiguracji elektronowej. Gra podpowie Ci, kt贸ry blok (`1s`, `2s`...) musisz teraz "napeni".</p>
                    </div>
                    <div>
                        <h3 class="text-pink-500 mb-1">2. ZBIERAJ ELEKTRONY</h3>
                        <p class="text-sm leading-relaxed text-gray-600">Gdy na ekranie pojawi si poprawny, p贸przezroczysty blok, <strong>przejd藕 przez niego</strong>. Za ka偶dym razem zostawisz w nim jeden elektron ().</p>
                    </div>
                    <div>
                        <h3 class="text-pink-500 mb-1">3. UNIKAJ PUAPEK</h3>
                        <p class="text-sm leading-relaxed text-gray-600">Wszystkie inne bloki (czerwone) to puapki. <strong>Przeskakuj nad nimi</strong>, aby nie przegra! Dotyczy to tak偶e orbitali, kt贸re ju偶 w peni zapenie.</p>
                    </div>
                </div>
                <p class="start-prompt text-gray-600 text-lg animate-pulse">Nacinij SPACJ, aby rozpocz</p>
            </div>
        </div>

        <div id="level-start-screen" class="hidden absolute inset-0 bg-white/95 p-6 overflow-y-auto z-20">
            <div class="level-start-screen-content text-center mx-auto">
                <h2 id="level-start-title" class="text-2xl text-gray-800 mb-4"></h2>
                <h3 class="text-lg text-pink-500 mb-2">Docelowa konfiguracja:</h3>
                <p id="level-start-config" class="text-xl text-gray-700 mb-8"></p>
                <p class="start-prompt text-gray-600 text-lg animate-pulse">Nacinij SPACJ, aby kontynuowa</p>
            </div>
        </div>

        <div id="player" class="absolute bottom-1 left-32 w-8 h-8 bg-pink-500 rounded-full shadow-md"></div>
        <div class="absolute bottom-0 left-0 w-full h-1 bg-gray-300"></div>
    </div>
    
    <script>
    (function() {
        // Wszystkie stae (player, gameContainer, itd.) bez zmian
        const player = document.getElementById('player');
        const gameContainer = document.getElementById('game-container');
        const stats = document.getElementById('stats');
        const levelTitle = document.getElementById('level-title');
        const startScreen = document.getElementById('start-screen');
        const levelStartScreen = document.getElementById('level-start-screen');
        const levelStartTitle = document.getElementById('level-start-title');
        const levelStartConfig = document.getElementById('level-start-config');

        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        const levels = [
            { name: "Wodoru (H)", config: { "1s": 1 } },
            { name: "Wgla (C)", config: { "1s": 2, "2s": 2, "2p": 2 } },
            { name: "Sodu (Na)", config: { "1s": 2, "2s": 2, "2p": 6, "3s": 1 } },
            { name: "Cynku (Zn)", config: { "1s": 2, "2s": 2, "2p": 6, "3s": 2, "3p": 6, "4s": 2, "3d": 10 } },
        ];
        
        const configSequence = ["1s", "2s", "2p", "3s", "3p", "4s", "3d", "4p", "5s", "4d", "5p", "6s", "4f", "5d", "6p", "7s", "5f", "6d", "7p"];
        const orbitalCapacities = { 's': 2, 'p': 6, 'd': 10, 'f': 14 };
        const orbitalBoxes = { 's': 1, 'p': 3, 'd': 5, 'f': 7 };
        
        let gameState = {
            isJumping: false,
            gameOver: true,
            gameStarted: false,
            levelScreenActive: false,
            // DODANE: Kluczowy element - blokada akcji
            actionLocked: false,
            currentLevelIndex: 0,
            progress: {},
            gameLoopId: null,
            obstacleSpawnerTimeout: null,
            obstacleSpeed: 7.5,
            trapChance: 0.4,
            lastSpawnedShell: null,
        };

        function initializeGame() {
            startScreen.classList.remove('hidden');
            levelStartScreen.classList.add('hidden');
            levelTitle.textContent = '';
            stats.innerHTML = '';
            updatePrompts();
            // DODANE: Odblokuj akcj, gdy gra jest gotowa na ekranie startowym
            gameState.actionLocked = false;
        }

        function firstStart() {
            if (gameState.gameStarted) return;
            gameState.gameStarted = true;
            startScreen.classList.add('hidden');
            showLevelStartScreen(0);
        }
        
        function showLevelStartScreen(levelIndex) {
            // ... (reszta funkcji bez zmian)
            const level = levels[levelIndex];
            gameState.currentLevelIndex = levelIndex;
            gameState.levelScreenActive = true;
            levelStartTitle.textContent = `Poziom ${levelIndex + 1}: Atom ${level.name}`;
            let configString = '';
            for(const shell of configSequence) {
                if(level.config[shell]) {
                    configString += `${shell}<sup>${level.config[shell]}</sup> `;
                }
            }
            levelStartConfig.innerHTML = configString;
            levelStartScreen.classList.remove('hidden');
            levelTitle.textContent = '';
            stats.innerHTML = '';
            updatePrompts();
            // DODANE: Odblokuj akcj, gdy ekran poziomu jest gotowy
            gameState.actionLocked = false;
        }

        function startLevelGameplay() {
            gameState.levelScreenActive = false;
            levelStartScreen.classList.add('hidden');
            gameState.progress = {};
            gameState.gameOver = false;
            gameState.lastSpawnedShell = null;
            document.querySelectorAll('.obstacle').forEach(o => o.remove());
            updateUI();
            gameLoop();
            spawnObstacle();
            // ZMIENIONE: Nie odblokowujemy tutaj akcji, bo gra si toczy.
            // Odblokowanie nastpi po wykonaniu skoku.
        }
        
        function advanceToNextLevel() {
            gameState.gameOver = true;
            const nextLevelIndex = gameState.currentLevelIndex + 1;
            
            if (nextLevelIndex < levels.length) {
                levelTitle.textContent = `Poziom ${gameState.currentLevelIndex + 1} ukoczony!`;
                // Czekamy na pokazanie kolejnego ekranu, blokada zostanie zwolniona w `showLevelStartScreen`
                setTimeout(() => showLevelStartScreen(nextLevelIndex), 2000);
            } else {
                endGame("Gratulacje! Ukoczye wszystkie poziomy!", true);
            }
        }

        function endGame(reason, isVictory = false) {
            gameState.gameOver = true;
            document.querySelectorAll('.obstacle').forEach(o => o.style.animationPlayState = 'paused');
            
            const finalMessage = isVictory ? 
                `<p class="text-green-500 text-2xl">${reason}</p>` :
                `<p class="text-red-500 text-xl">KONIEC GRY!</p><p class="text-gray-600 mt-1">${reason}</p>`;

            stats.innerHTML = `${finalMessage}<p class="start-prompt text-gray-600 mt-2 animate-pulse">Nacinij SPACJ, aby zagra ponownie.</p>`;
            updatePrompts();
            // DODANE: Odblokuj akcj, gdy pojawi si ekran koca gry
            gameState.actionLocked = false;
        }

        // Reszta funkcji (gameLoop, checkInteractions, itd.) jest bez zmian,
        // kluczowe zmiany s w obsudze wejcia poni偶ej.
        // ...
        
        function jump() {
            // ZMIENIONE: Usunito std warunek sprawdzajcy, bo jest teraz w `handlePrimaryAction`
            gameState.isJumping = true;
            player.classList.add('jumping');
            player.addEventListener('animationend', () => {
                player.classList.remove('jumping');
                gameState.isJumping = false;
            }, { once: true });
        }

        // --- ZMIENIONA, KLUCZOWA LOGIKA OBSUGI WEJCIA ---

        function handlePrimaryAction() {
            // 1. Sprawd藕, czy akcja jest zablokowana. Jeli tak, nie r贸b nic.
            if (gameState.actionLocked) return;

            // 2. Jeli nie jest, natychmiast j zablokuj.
            gameState.actionLocked = true;

            // 3. Wykonaj odpowiedni akcj w zale偶noci od stanu gry
            if (!gameState.gameStarted) {
                firstStart();
                // Blokada zostanie zwolniona w `showLevelStartScreen`
            } else if (gameState.levelScreenActive) {
                startLevelGameplay();
                // Blokada celowo POZOSTAJE aktywna, odblokuje j pierwszy skok
            } else if (gameState.gameOver) {
                gameState.gameStarted = false;
                gameState.currentLevelIndex = 0;
                initializeGame();
                 // Blokada zostanie zwolniona w `initializeGame`
            } else {
                 // Sprawdzamy, czy gracz nie jest w trakcie skoku
                 if (!gameState.isJumping) {
                    jump();
                 }
                // 4. Ustaw kr贸tki cooldown, po kt贸rym akcja zostanie odblokowana.
                //    Zapobiega to zbyt szybkiemu, seryjnemu skakaniu.
                setTimeout(() => {
                    gameState.actionLocked = false;
                }, 300); // 300ms przerwy midzy akcjami
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                handlePrimaryAction();
            }
        });
        
        document.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handlePrimaryAction();
        }, { passive: false });


        // ... Tutaj caa reszta funkcji bez zmian (checkInteractions, createObstacle, etc.) ...
        // ... Wklej je tutaj, aby kod by kompletny ...
        // Poni偶ej wklejam je dla pewnoci, 偶e nic nie zgino.
        function checkLevelCompletion(){const targetConfig=levels[gameState.currentLevelIndex].config;for(const shell in targetConfig){if((gameState.progress[shell]||0)<targetConfig[shell]){return false}}return true}function getNextRequiredShell(){const targetConfig=levels[gameState.currentLevelIndex].config;for(const shell of configSequence){if(targetConfig[shell]&&(gameState.progress[shell]||0)<targetConfig[shell]){return shell}}return null}function spawnObstacle(){if(gameState.gameOver)return;const requiredShell=getNextRequiredShell();if(!requiredShell)return;const lastSpawned=gameState.lastSpawnedShell;const allLevelShells=Object.keys(levels[gameState.currentLevelIndex].config);let availableToSpawn=allLevelShells.filter(s=>s!==lastSpawned);if(availableToSpawn.length===0){availableToSpawn=allLevelShells}let shellToSpawn;const shouldSpawnRequired=Math.random()>gameState.trapChance;if(shouldSpawnRequired&&availableToSpawn.includes(requiredShell)){shellToSpawn=requiredShell}else{const trapPool=availableToSpawn.filter(s=>s!==requiredShell);if(trapPool.length>0){shellToSpawn=trapPool[Math.floor(Math.random()*trapPool.length)]}else{shellToSpawn=availableToSpawn[0]}}
        gameState.lastSpawnedShell=shellToSpawn;createObstacle(shellToSpawn);clearTimeout(gameState.obstacleSpawnerTimeout);gameState.obstacleSpawnerTimeout=setTimeout(spawnObstacle,Math.random()*1000+2500)}function cleanupObstacles(){const gameRect=gameContainer.getBoundingClientRect();document.querySelectorAll('.obstacle').forEach(obstacle=>{const obstacleRect=obstacle.getBoundingClientRect();if(obstacleRect.right<gameRect.left-50){obstacle.remove()}})}function redrawElectronsInObstacle(obstacle){const shell=obstacle.dataset.shell;const electronsToDraw=gameState.progress[shell]||0;const shellType=shell.charAt(1);const numBoxes=orbitalBoxes[shellType];const orbitalBoxesInObstacle=obstacle.querySelectorAll('[data-orbital-index]');orbitalBoxesInObstacle.forEach(box=>box.innerHTML='');for(let i=1;i<=electronsToDraw;i++){const electron=document.createElement('div');electron.classList.add('w-3','h-3','bg-orange-400','rounded-full','electron');const boxIndex=(i-1)%numBoxes;const targetBox=orbitalBoxesInObstacle[boxIndex];if(targetBox){targetBox.appendChild(electron)}}}
        function createObstacle(shell){const obstacle=document.createElement('div');const shellType=shell.charAt(1);const boxCount=orbitalBoxes[shellType]||1;let obstacleWidth='w-24';let borderColor='border-gray-400';if(shellType==='s'){obstacleWidth='w-12';borderColor='border-purple-400'}if(shellType==='p'){obstacleWidth='w-32';borderColor='border-orange-400'}if(shellType==='d'){obstacleWidth='w-48';borderColor='border-blue-400'}if(shellType==='f'){obstacleWidth='w-64';borderColor='border-red-500'}obstacle.classList.add('obstacle','absolute','bottom-1',obstacleWidth,'h-12','flex','flex-col','items-center','justify-center','rounded-md','border-2','p-1','bg-white','shadow');obstacle.dataset.shell=shell;obstacle.style.animationDuration=`${gameState.obstacleSpeed}s`;const requiredShell=getNextRequiredShell();const isTrap=(shell!==requiredShell);obstacle.dataset.isTrap=isTrap;const text=document.createElement('span');text.classList.add('obstacle-text','text-xs','text-gray-700');text.textContent=shell;const electronContainer=document.createElement('div');
        electronContainer.classList.add('electron-container','flex','flex-wrap','justify-center','gap-1','h-6','items-center','mt-1');obstacle.appendChild(text);obstacle.appendChild(electronContainer);if(boxCount>0){for(let i=0;i<boxCount;i++){const orbitalBox=document.createElement('div');orbitalBox.classList.add('w-8','h-full','border',borderColor,'flex','items-center','justify-center','flex-wrap','gap-px','p-px','rounded-sm');orbitalBox.dataset.orbitalIndex=i;electronContainer.appendChild(orbitalBox)}}if(isTrap){obstacle.classList.add('bg-red-200','border-red-500')}else{obstacle.classList.add('bg-gray-50/80',borderColor);obstacle.style.borderStyle='dashed'}gameContainer.appendChild(obstacle);redrawElectronsInObstacle(obstacle)}function updateUI(){if(gameState.gameOver)return;const level=levels[gameState.currentLevelIndex];levelTitle.textContent=`Uzupenij konfiguracj atomu ${level.name}`;let progressText='';const targetConfig=level.config;for(const shell of configSequence){if(targetConfig[shell]){const current=gameState.progress[shell]||0;
        const countColor=current>0?'text-orange-500 font-bold':'text-gray-800';progressText+=`<span>${shell}<sup class="${countColor}">${current}</sup><sup class="text-gray-500">/${targetConfig[shell]}</sup></span> `}}stats.innerHTML=`<p class="tracking-widest">${progressText}</p>`}function updatePrompts(){const promptElements=document.querySelectorAll('.start-prompt');const text=isTouchDevice?"Dotknij ekranu":"Nacinij SPACJ";promptElements.forEach(el=>{if(el.textContent.includes("rozpocz")){el.textContent=`${text}, aby rozpocz`}else if(el.textContent.includes("kontynuowa")){el.textContent=`${text}, aby kontynuowa`}else if(el.textContent.includes("ponownie")){el.textContent=`${text}, aby zagra ponownie.`}})}

        document.addEventListener('DOMContentLoaded', initializeGame);
    })();
    </script>
</body>
</html>
